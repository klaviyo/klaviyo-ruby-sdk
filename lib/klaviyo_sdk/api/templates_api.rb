=begin
#Klaviyo API

#Empowering creators to own their destiny

The version of the OpenAPI document: 2022.03.29

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.4.0

=end

require 'cgi'

module Klaviyo
  class TemplatesApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Clone Template
    # Creates a copy of a given template with a new name.
    # @param template_id [String] 
    # @param name [String] The new name of the email template.
    # @param [Hash] opts the optional parameters
    # @return [Template]
    def clone_template(template_id, name, opts = {})
      data, _status_code, _headers = clone_template_with_http_info(template_id, name, opts)
      data
    end

    # Clone Template
    # Creates a copy of a given template with a new name.
    # @param template_id [String] 
    # @param name [String] The new name of the email template.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Template, Integer, Hash)>] Template data, response status code and response headers
    def clone_template_with_http_info(template_id, name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TemplatesApi.clone_template ...'
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling TemplatesApi.clone_template"
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling TemplatesApi.clone_template"
      end
      # resource path
      local_var_path = '/v1/email-template/{template_id}/clone'.sub('{' + 'template_id' + '}', CGI.escape(template_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['name'] = name

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'Template'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"TemplatesApi.clone_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TemplatesApi#clone_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create New Template
    # Creates a new email template.
    # @param name [String] The name of the email template.
    # @param html [String] 
    # @param [Hash] opts the optional parameters
    # @return [Template]
    def create_template(name, html, opts = {})
      data, _status_code, _headers = create_template_with_http_info(name, html, opts)
      data
    end

    # Create New Template
    # Creates a new email template.
    # @param name [String] The name of the email template.
    # @param html [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Template, Integer, Hash)>] Template data, response status code and response headers
    def create_template_with_http_info(name, html, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TemplatesApi.create_template ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling TemplatesApi.create_template"
      end
      # verify the required parameter 'html' is set
      if @api_client.config.client_side_validation && html.nil?
        fail ArgumentError, "Missing the required parameter 'html' when calling TemplatesApi.create_template"
      end
      # resource path
      local_var_path = '/v1/email-templates'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['name'] = name
      form_params['html'] = html

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'Template'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"TemplatesApi.create_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TemplatesApi#create_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Template
    # Deletes a given template.
    # @param template_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Hash<String, Object>]
    def delete_template(template_id, opts = {})
      data, _status_code, _headers = delete_template_with_http_info(template_id, opts)
      data
    end

    # Delete Template
    # Deletes a given template.
    # @param template_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Hash<String, Object>, Integer, Hash)>] Hash<String, Object> data, response status code and response headers
    def delete_template_with_http_info(template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TemplatesApi.delete_template ...'
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling TemplatesApi.delete_template"
      end
      # resource path
      local_var_path = '/v1/email-template/{template_id}'.sub('{' + 'template_id' + '}', CGI.escape(template_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, Object>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"TemplatesApi.delete_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TemplatesApi#delete_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get All Templates
    # Returns a list of all the email templates you've created. The templates are returned in sorted order by `name`.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page For pagination, which page of results to return. Default &#x3D; 0 (default to 0)
    # @option opts [Integer] :count For pagination, the number of results to return. Max &#x3D; 100 (default to 50)
    # @return [Hash<String, Object>]
    def get_templates(opts = {})
      data, _status_code, _headers = get_templates_with_http_info(opts)
      data
    end

    # Get All Templates
    # Returns a list of all the email templates you&#39;ve created. The templates are returned in sorted order by &#x60;name&#x60;.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page For pagination, which page of results to return. Default &#x3D; 0
    # @option opts [Integer] :count For pagination, the number of results to return. Max &#x3D; 100
    # @return [Array<(Hash<String, Object>, Integer, Hash)>] Hash<String, Object> data, response status code and response headers
    def get_templates_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TemplatesApi.get_templates ...'
      end
      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling TemplatesApi.get_templates, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] > 100
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling TemplatesApi.get_templates, must be smaller than or equal to 100.'
      end

      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling TemplatesApi.get_templates, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/v1/email-templates'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, Object>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"TemplatesApi.get_templates",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TemplatesApi#get_templates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Render Template
    # Renders the specified template with the provided data and return HTML and text versions of the email.
    # @param template_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. (default to '{ \"name\" : \"George Washington\", \"state\" : \"VA\" }')
    # @return [RenderedTemplate]
    def render_template(template_id, opts = {})
      data, _status_code, _headers = render_template_with_http_info(template_id, opts)
      data
    end

    # Render Template
    # Renders the specified template with the provided data and return HTML and text versions of the email.
    # @param template_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing.
    # @return [Array<(RenderedTemplate, Integer, Hash)>] RenderedTemplate data, response status code and response headers
    def render_template_with_http_info(template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TemplatesApi.render_template ...'
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling TemplatesApi.render_template"
      end
      # resource path
      local_var_path = '/v1/email-template/{template_id}/render'.sub('{' + 'template_id' + '}', CGI.escape(template_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['context'] = opts[:'context'] if !opts[:'context'].nil?

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'RenderedTemplate'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"TemplatesApi.render_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TemplatesApi#render_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Render and Send Template
    # Renders the specified template with the provided data and send the contents in an email via the service specified. This API is intended to test templates only, and is rate limited to the following thresholds: 100/hour, 1,000/day.
    # @param template_id [String] 
    # @param from_email [String] 
    # @param from_name [String] 
    # @param subject [String] 
    # @param to [String] **Mixed**. string, or JSON encoded array of objects with \\\&quot;email\\\&quot; and \\\&quot;name\\\&quot; keys. &#x60;abraham.lincoln@klaviyo.com&#x60; OR &#x60;[{\\\&quot;name\\\&quot;:\\\&quot;Abraham Lincoln\\\&quot;,\\\&quot;email\\\&quot;:\\\&quot;abraham.lincoln@klaviyo.com\\\&quot;}]&#x60; 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context Optional, JSON object. This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. ex: &#x60;{ \\\&quot;name\\\&quot; : \\\&quot;George Washington\\\&quot;, \\\&quot;state\\\&quot; : \\\&quot;VA\\\&quot; }&#x60;  (default to '{ \"name\" : \"George Washington\", \"state\" : \"VA\" }')
    # @return [RenderedTemplate]
    def send_template(template_id, from_email, from_name, subject, to, opts = {})
      data, _status_code, _headers = send_template_with_http_info(template_id, from_email, from_name, subject, to, opts)
      data
    end

    # Render and Send Template
    # Renders the specified template with the provided data and send the contents in an email via the service specified. This API is intended to test templates only, and is rate limited to the following thresholds: 100/hour, 1,000/day.
    # @param template_id [String] 
    # @param from_email [String] 
    # @param from_name [String] 
    # @param subject [String] 
    # @param to [String] **Mixed**. string, or JSON encoded array of objects with \\\&quot;email\\\&quot; and \\\&quot;name\\\&quot; keys. &#x60;abraham.lincoln@klaviyo.com&#x60; OR &#x60;[{\\\&quot;name\\\&quot;:\\\&quot;Abraham Lincoln\\\&quot;,\\\&quot;email\\\&quot;:\\\&quot;abraham.lincoln@klaviyo.com\\\&quot;}]&#x60; 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context Optional, JSON object. This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. ex: &#x60;{ \\\&quot;name\\\&quot; : \\\&quot;George Washington\\\&quot;, \\\&quot;state\\\&quot; : \\\&quot;VA\\\&quot; }&#x60; 
    # @return [Array<(RenderedTemplate, Integer, Hash)>] RenderedTemplate data, response status code and response headers
    def send_template_with_http_info(template_id, from_email, from_name, subject, to, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TemplatesApi.send_template ...'
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling TemplatesApi.send_template"
      end
      # verify the required parameter 'from_email' is set
      if @api_client.config.client_side_validation && from_email.nil?
        fail ArgumentError, "Missing the required parameter 'from_email' when calling TemplatesApi.send_template"
      end
      # verify the required parameter 'from_name' is set
      if @api_client.config.client_side_validation && from_name.nil?
        fail ArgumentError, "Missing the required parameter 'from_name' when calling TemplatesApi.send_template"
      end
      # verify the required parameter 'subject' is set
      if @api_client.config.client_side_validation && subject.nil?
        fail ArgumentError, "Missing the required parameter 'subject' when calling TemplatesApi.send_template"
      end
      # verify the required parameter 'to' is set
      if @api_client.config.client_side_validation && to.nil?
        fail ArgumentError, "Missing the required parameter 'to' when calling TemplatesApi.send_template"
      end
      # resource path
      local_var_path = '/v1/email-template/{template_id}/send'.sub('{' + 'template_id' + '}', CGI.escape(template_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['from_email'] = from_email
      form_params['from_name'] = from_name
      form_params['subject'] = subject
      form_params['to'] = to
      form_params['context'] = opts[:'context'] if !opts[:'context'].nil?

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'RenderedTemplate'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"TemplatesApi.send_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TemplatesApi#send_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Template
    # Updates the name and/or HTML content of a template. Only updates imported HTML templates; does not currently update drag & drop templates.
    # @param template_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :name The new name of the email template.
    # @option opts [String] :html The new HTML content for this template.
    # @return [Template]
    def update_template(template_id, opts = {})
      data, _status_code, _headers = update_template_with_http_info(template_id, opts)
      data
    end

    # Update Template
    # Updates the name and/or HTML content of a template. Only updates imported HTML templates; does not currently update drag &amp; drop templates.
    # @param template_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :name The new name of the email template.
    # @option opts [String] :html The new HTML content for this template.
    # @return [Array<(Template, Integer, Hash)>] Template data, response status code and response headers
    def update_template_with_http_info(template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TemplatesApi.update_template ...'
      end
      # verify the required parameter 'template_id' is set
      if @api_client.config.client_side_validation && template_id.nil?
        fail ArgumentError, "Missing the required parameter 'template_id' when calling TemplatesApi.update_template"
      end
      # resource path
      local_var_path = '/v1/email-template/{template_id}'.sub('{' + 'template_id' + '}', CGI.escape(template_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-www-form-urlencoded'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['name'] = opts[:'name'] if !opts[:'name'].nil?
      form_params['html'] = opts[:'html'] if !opts[:'html'].nil?

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'Template'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"TemplatesApi.update_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TemplatesApi#update_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
