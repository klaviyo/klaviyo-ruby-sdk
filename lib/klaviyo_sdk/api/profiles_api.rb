=begin
#Klaviyo API

#Empowering creators to own their destiny

The version of the OpenAPI document: 2022.03.29

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.4.0

=end

require 'cgi'

module Klaviyo
  class ProfilesApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Exchange ID for Profile ID
    # Klaviyo's web tracking uses an encrypted identifier. However, there are many use cases that require developers to have access to a given profile's email or phone number. In such cases, developers can use this operation to exchange an encrypted identifier for a profile ID, which they can then use to retrieve the full profile data (by making a subsequent request to the `get-profiles` operation).  The `exchange_id` takes the following form:  `<IDENTIFIER>.<COMPANY_ID>`  The `exchange_id` appears in the url as follows:  `?_kx=<IDENTIFIER>.<COMPANY_ID>`
    # @param [Hash] opts the optional parameters
    # @option opts [InlineObject] :inline_object 
    # @return [Hash<String, Object>]
    def exchange(opts = {})
      data, _status_code, _headers = exchange_with_http_info(opts)
      data
    end

    # Exchange ID for Profile ID
    # Klaviyo&#39;s web tracking uses an encrypted identifier. However, there are many use cases that require developers to have access to a given profile&#39;s email or phone number. In such cases, developers can use this operation to exchange an encrypted identifier for a profile ID, which they can then use to retrieve the full profile data (by making a subsequent request to the &#x60;get-profiles&#x60; operation).  The &#x60;exchange_id&#x60; takes the following form:  &#x60;&lt;IDENTIFIER&gt;.&lt;COMPANY_ID&gt;&#x60;  The &#x60;exchange_id&#x60; appears in the url as follows:  &#x60;?_kx&#x3D;&lt;IDENTIFIER&gt;.&lt;COMPANY_ID&gt;&#x60;
    # @param [Hash] opts the optional parameters
    # @option opts [InlineObject] :inline_object 
    # @return [Array<(Hash<String, Object>, Integer, Hash)>] Hash<String, Object> data, response status code and response headers
    def exchange_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProfilesApi.exchange ...'
      end
      # resource path
      local_var_path = '/v2/people/exchange'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(opts[:'inline_object'])

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, Object>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"ProfilesApi.exchange",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProfilesApi#exchange\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Profile ID
    #
    # Retrieves all the data attributes for a person, based on the Klaviyo Person ID.
    # This method will only allow searching with one search parameter. Precedence of parameters is:
    # - email
    # - phone_number
    # - external_id
    #
    # @param [Hash] opts the optional parameters
    # @return [Hash] object with id key for person profile id
    def get_profile_id(opts = {})
      data, _status_code, _headers = get_profile_id_with_http_info(opts)
      data
    end

    # Get Profile ID
    #
    # Retrieves all the data attributes for a person, based on the Klaviyo Person ID.
    # This method will only allow searching with one search parameter. Precedence of parameters is:
    # - email
    # - phone_number
    # - external_id
    #
    # @param [Hash] opts the optional parameters
    # @return [Array<(Hash, Integer, Hash)>] Profile id object, response status code and response headers
    def get_profile_id_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProfilesApi.get_profile_id ...'
      end

      search_param = opts[:query_params] && (opts[:query_params][:email] || opts[:query_params][:phone_number] || opts[:query_params][:external_id])
      if @api_client.config.client_side_validation && !search_param
        fail ArgumentError, "Missing the required query parameter 'email', 'phone_number', or 'external_id' when calling ProfilesApi.get_profile_id"
      end

      # resource path
      local_var_path = '/v2/people/search'

      # query parameters
      query_params = opts[:query_params]

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, Object>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"ProfilesApi.get_profile_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProfilesApi#get_profile_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Profile
    # Retrieves all the data attributes for a person, based on the Klaviyo Person ID.
    # @param person_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Person]
    def get_profile(person_id, opts = {})
      data, _status_code, _headers = get_profile_with_http_info(person_id, opts)
      data
    end

    # Get Profile
    # Retrieves all the data attributes for a person, based on the Klaviyo Person ID.
    # @param person_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def get_profile_with_http_info(person_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProfilesApi.get_profile ...'
      end
      # verify the required parameter 'person_id' is set
      if @api_client.config.client_side_validation && person_id.nil?
        fail ArgumentError, "Missing the required parameter 'person_id' when calling ProfilesApi.get_profile"
      end
      # resource path
      local_var_path = '/v1/person/{person_id}'.sub('{' + 'person_id' + '}', CGI.escape(person_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'Person'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"ProfilesApi.get_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProfilesApi#get_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Profile's Events for a Specific Metric
    # Returns a person's batched timeline for one specific event type.
    # @param person_id [String] 
    # @param metric_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :since Either a 10-digit Unix timestamp (UTC) to use as starting datetime, OR a pagination token obtained from the next attribute of a prior API call. For backwards compatibility, UUIDs will continue to be supported for a limited time. Defaults to current time.
    # @option opts [Integer] :count Number of events to return in a batch. (default to 50)
    # @option opts [String] :sort Sort order to apply to timeline, either descending or ascending. Valid values are &#x60;desc&#x60; or &#x60;asc&#x60;. Defaults to &#x60;desc&#x60;. (default to 'desc')
    # @return [MetricTimeline]
    def profile_metric_timeline(person_id, metric_id, opts = {})
      data, _status_code, _headers = profile_metric_timeline_with_http_info(person_id, metric_id, opts)
      data
    end

    # Get Profile&#39;s Events for a Specific Metric
    # Returns a person&#39;s batched timeline for one specific event type.
    # @param person_id [String] 
    # @param metric_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :since Either a 10-digit Unix timestamp (UTC) to use as starting datetime, OR a pagination token obtained from the next attribute of a prior API call. For backwards compatibility, UUIDs will continue to be supported for a limited time. Defaults to current time.
    # @option opts [Integer] :count Number of events to return in a batch.
    # @option opts [String] :sort Sort order to apply to timeline, either descending or ascending. Valid values are &#x60;desc&#x60; or &#x60;asc&#x60;. Defaults to &#x60;desc&#x60;.
    # @return [Array<(MetricTimeline, Integer, Hash)>] MetricTimeline data, response status code and response headers
    def profile_metric_timeline_with_http_info(person_id, metric_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProfilesApi.profile_metric_timeline ...'
      end
      # verify the required parameter 'person_id' is set
      if @api_client.config.client_side_validation && person_id.nil?
        fail ArgumentError, "Missing the required parameter 'person_id' when calling ProfilesApi.profile_metric_timeline"
      end
      # verify the required parameter 'metric_id' is set
      if @api_client.config.client_side_validation && metric_id.nil?
        fail ArgumentError, "Missing the required parameter 'metric_id' when calling ProfilesApi.profile_metric_timeline"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] > 100
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling ProfilesApi.profile_metric_timeline, must be smaller than or equal to 100.'
      end

      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling ProfilesApi.profile_metric_timeline, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/v1/person/{person_id}/metric/{metric_id}/timeline'.sub('{' + 'person_id' + '}', CGI.escape(person_id.to_s)).sub('{' + 'metric_id' + '}', CGI.escape(metric_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'since'] = opts[:'since'] if !opts[:'since'].nil?
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'MetricTimeline'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"ProfilesApi.profile_metric_timeline",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProfilesApi#profile_metric_timeline\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Profile's Events for all Metrics
    # Returns a batched timeline of all events for a person.
    # @param person_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :since Either a 10-digit Unix timestamp (UTC) to use as starting datetime, OR a pagination token obtained from the next attribute of a prior API call. For backwards compatibility, UUIDs will continue to be supported for a limited time. Defaults to current time.
    # @option opts [Integer] :count Number of events to return in a batch. Default &#x3D; 50, Max &#x3D; 100 (default to 50)
    # @option opts [String] :sort Sort order to apply to timeline, either descending or ascending. Valid values are &#x60;desc&#x60; or &#x60;asc&#x60;. Defaults to &#x60;desc&#x60;. Always descending when &#x60;since&#x60; is not sent, as &#x60;since&#x60; defaults to current time. (default to 'desc')
    # @return [MetricTimeline]
    def profile_metrics_timeline(person_id, opts = {})
      data, _status_code, _headers = profile_metrics_timeline_with_http_info(person_id, opts)
      data
    end

    # Get Profile&#39;s Events for all Metrics
    # Returns a batched timeline of all events for a person.
    # @param person_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :since Either a 10-digit Unix timestamp (UTC) to use as starting datetime, OR a pagination token obtained from the next attribute of a prior API call. For backwards compatibility, UUIDs will continue to be supported for a limited time. Defaults to current time.
    # @option opts [Integer] :count Number of events to return in a batch. Default &#x3D; 50, Max &#x3D; 100
    # @option opts [String] :sort Sort order to apply to timeline, either descending or ascending. Valid values are &#x60;desc&#x60; or &#x60;asc&#x60;. Defaults to &#x60;desc&#x60;. Always descending when &#x60;since&#x60; is not sent, as &#x60;since&#x60; defaults to current time.
    # @return [Array<(MetricTimeline, Integer, Hash)>] MetricTimeline data, response status code and response headers
    def profile_metrics_timeline_with_http_info(person_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProfilesApi.profile_metrics_timeline ...'
      end
      # verify the required parameter 'person_id' is set
      if @api_client.config.client_side_validation && person_id.nil?
        fail ArgumentError, "Missing the required parameter 'person_id' when calling ProfilesApi.profile_metrics_timeline"
      end
      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] > 100
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling ProfilesApi.profile_metrics_timeline, must be smaller than or equal to 100.'
      end

      if @api_client.config.client_side_validation && !opts[:'count'].nil? && opts[:'count'] < 1
        fail ArgumentError, 'invalid value for "opts[:"count"]" when calling ProfilesApi.profile_metrics_timeline, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/v1/person/{person_id}/metrics/timeline'.sub('{' + 'person_id' + '}', CGI.escape(person_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'since'] = opts[:'since'] if !opts[:'since'].nil?
      query_params[:'count'] = opts[:'count'] if !opts[:'count'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'MetricTimeline'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"ProfilesApi.profile_metrics_timeline",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProfilesApi#profile_metrics_timeline\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Profile
    # NOTE: If you are interested in creating or updating profiles in Klaviyo, you should be using the Identify API instead. The best use-case for this route is changing a profiles's email address or other primary identifier after a profile already exists in Klaviyo.  Add or update one more more attributes for a Person, based on the Klaviyo Person ID. If a property already exists, it will be updated. If a property is not set for that record, it will be created.  You can update any attribute, by sending one or more attributes along their new values, as query parameters. Recommended attributes for this endpoint: `$email`, `$phone_number`, `$id` 
    # @param person_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :params 
    # @return [Person]
    def update_profile(person_id, opts = {})
      data, _status_code, _headers = update_profile_with_http_info(person_id, opts)
      data
    end

    # Update Profile
    # NOTE: If you are interested in creating or updating profiles in Klaviyo, you should be using the Identify API instead. The best use-case for this route is changing a profiles&#39;s email address or other primary identifier after a profile already exists in Klaviyo.  Add or update one more more attributes for a Person, based on the Klaviyo Person ID. If a property already exists, it will be updated. If a property is not set for that record, it will be created.  You can update any attribute, by sending one or more attributes along their new values, as query parameters. Recommended attributes for this endpoint: &#x60;$email&#x60;, &#x60;$phone_number&#x60;, &#x60;$id&#x60; 
    # @param person_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :params 
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def update_profile_with_http_info(person_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProfilesApi.update_profile ...'
      end
      # verify the required parameter 'person_id' is set
      if @api_client.config.client_side_validation && person_id.nil?
        fail ArgumentError, "Missing the required parameter 'person_id' when calling ProfilesApi.update_profile"
      end
      # resource path
      local_var_path = '/v1/person/{person_id}'.sub('{' + 'person_id' + '}', CGI.escape(person_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'params'] = opts[:'params'] if !opts[:'params'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body]

      # return_type
      return_type = opts[:debug_return_type] || 'Person'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"ProfilesApi.update_profile",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProfilesApi#update_profile\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
